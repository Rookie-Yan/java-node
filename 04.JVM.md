# 1. JVM结构

<img src="https://img-blog.csdnimg.cn/20210302100007914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyMDM1NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />

## 1.1 线程共享（堆和方法区）

### 堆

​		**一个JVM只有一个堆内存 并且堆内存的大小时可以调节的 其中存储类、方法、常量、变量和所有引用类型的真实对象**

​		使用jmap查看堆内存占用情况，jmap -heap 进程id  查看（jps获取进程号）  （还可以在IDEA下面输入jconsole或jvirsualvm使用图形化接面）

### 方法区

​		**静态变量（1.6之前放在方法区，因为方法区在永久代，属于堆内存）、常量类信息（构造方法、接口定义）、运行时的常量池存储在方法区中，（static，final，Class，常量池）**1.8之后方法区被放入元空间（属于本地内存（直接内存），不是JVM内存了，但是Stringtable仍然放在堆中），又叫非堆，也会造成内存溢出OOM。方法区在JVM启动的时候创建

​		直接内存：java和CPU都可以进行操作的，零拷贝中的直接内存，使用NIO的buffer也是使用的直接内存，不受jvm内存回收管理。需要使用unsafe中的freeMemory方法进行主动的释放，jvm使用虚引用将其与btebuffer关联，当bytebuffer被GC后，会触发unsafe的方法进行直接内存的回收。在JVM性能调优时，可能会禁用显示的垃圾回收（System.gc()无效），因为System.gc()时full GC，占用资源较多。但是这样就只能将直接内存的回收交给JVM，（full GC时会清理掉虚引用对象，从而触发直接内存的回收），所以如果需要，可以手动调用System.gc()进行直接内存的回收

​		每个类被编译成.class文件之后，会有一个常量池来存储类中的常量信息，在运行时，常量池会被放入运行时常量池。

**StringTable串池**（可以被垃圾回收）

* 串池在1.6放入的是永久代，但是垃圾回收需要full GC才会触发，回收效率低，1.8之后放入堆中
* 字符串常量池（串池）使用的懒加载，在需要使用某个字符串常量时，会将其放入串池
* 串池中有的，不会再创建
* 字符串变量拼接的原理是StringBuilder  （会new新对象，存在堆中）
* 字符串常量拼接的原理是编译器优化 （不会创建新的对象）
* 使用intern方法可以尝试将自负床放入串池，1.8之后如果放入成功，串池中==堆中，1.6使用的是拷贝，创建新对象 串池中 不== 堆
* 底层使用的是hash表，查找，确实是否存在都需要进行查找，如果桶的个数太少，那么哈希冲突增加，链表长度会增加，查找速率会变慢。可以使用-XX:StringTableSize=4000(大于1009)改变桶个数进行调优
* 如果需要使用大量字符串，并且可能存在重复，可以考虑使用intern入串池，然后减少堆内存的使用

```java
String s1="a";
String s2="b";
String s2="ab";
String s4=s1+s2;
//被字节码编译之后执行的是 StringBuilder（）.append("a").append("b").toString() new String("ab")
//因为s1,s2均为变量，在运行时需要从运行时常量池中拿到之后再相加，结果不确定，所以使用new 所以s3==s4  为false s3其实在堆中
String s5="a"+"b";
//因为相加的字符串位于字符串常量池中，是常量，所以结果是确定的，这时检查到字符串常量池中有结果"ab"，所以直接使用
//所以s3==s5  为true
//intern方法可以尝试将字符串放入串池，如果成功，那么放入的就是和堆中的对象一致，如果串池中存在了，那么返回的就是串池中的对象，和堆中的对象不==（1.8）  在1.6，即使不存在，也会重新拷贝一个对象放入，此时堆中和串池中的不==
```



## 1.2 线程私有（JAVA栈、本地方法栈、程序计数器）

### 1. java栈

**栈内存 主管程序的运行 生命周期和线程同步**  **线程私有**
不同的线程调用不同的方法时，就将方法压入栈中，线程结束，栈内存就释放 ，对于栈来说，**不存在垃圾回收机制**，一旦线程全部结束，栈就结束了。

**栈用来描述线程运行需要的内存空间**。栈由多个**栈帧**组成，**表示每个方法运行时需要的内存**，包括局部变量、参数、返回地址等，每个线程只能有一个**活动栈帧（在栈顶）**，表示正在执行的方法。

存放**8大基本类型+对象引用+实例的方法**

* 栈划分越大越好？整个栈的物理内存是一定的，单个线程栈越大，线程并发就会较少，而且栈的大小并不能提升方法运行效率，只能提升递归的次数
* 线程安全？**局部变量，没有逃离该方法就是线程安全的**（仅在该方法中使用），如果是局部变量，**引用了对象**，并且**逃离该方法**（可能是别的方法的参数引入，也可以是作为该方法返回值返回）**需要考虑线程安全**
* **栈内存溢出**： 栈帧过多（递归条件没有生效）、栈帧过大（一般不会出现）、第三方库使用错误（json字符串转换出现类的循环引用）
* **CPU占用过高**：**top**查看哪个进程占用高，可以拿到pid（线程ID）------> **ps H -eo pid，tid，%cpu|grep pid** 查看进程中各个线程的CPU占用------->**jstack 进程id**（找的时候需要将十进制转为十六进制）根据线程ID进一步查找到问题代码的位置

### 2. 本地方法栈

 JNI    **扩展java的使用 使用不同语言的方法** 为本地方法的运行提供内存

### 3. 程序计数器

**线程私有，不存在内存溢出问题**    作用是用来指向方法区中的方法字节码，确定下一条语句的执行。是由 **寄存器** 实现的，在线程切换的时候可以记住jvm下一条待执行的指令地址，在上下文恢复的时候直接读取。



## 1.3 变量的存储

​		局部变量，如果是基本数据类型，那么就直接存在栈中，如果是引用数据类型，比如String str = new String("12");,会把对象存在堆中，对象的引用（指针）存在栈中

​		成员变量，类的成员在不同对象中各不相同，基本数据类型和引用数据类型都存储在这个对象中，作为一个整体存储在堆中。而类的方法是所有的对象共享的，方法是存在方法区的，只有当调用的时候才会被压栈，不用的时候是占内存的。

​		静态成员变量只会在类加载的时候加载一次，是跟类加载产生的class文件放在一起，存在堆内存中的，但是class会指向方法区中的java_mirror，其中包含了java类的常量池、常量类信息等。


# 2. 类加载系统

## 2.1 双亲委派机制

### ClassLoader分类

​		类加载器包括**启动类（根）加载器 ** **Bootstrap classLoader**、**扩展类加载器** **ExtClassLoader**、**应用程序加载器** **AppClassLoader**以及**用户自定义类加载器**。

### 双亲委派加载过程

​		不考虑自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。
​		**自上而下检测自己是否有加载过，如果没有就寻找父类，看父类有没有加载。如果直到启动类加载器都没有加载过，在从上至下看能否进行加载，如果自己能够加载，就加载，如果不能加载，就交给子类进行加载**

### 双亲委派的优势和劣势

* 优势：保证安全，自定义的类不会破坏原有的JVM类  即使自定义，JVM还是会优先加载已有的类，防止危险代码的植入
* 劣势：父级加载器无法加载子级类加载器路径中的类

### 如何破坏双亲委派

​		使用上下文类加载器，可以通过Thread.setContextClassLoaser()方法设置的 。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。





## 2.2 类加载过程

![img](https://img-blog.csdnimg.cn/2019062014564165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9jdWl0,size_16,color_FFFFFF,t_70)



1. 类加载时机：

   加载（loading）阶段，java虚拟机规范中没有进行约束，

2. 类加载各个过程

![image-20210727224926228](D:\Typora\image\image-20210727224926228.png)

**加载阶段：** 

* 通过类的全限定类名获取此类的二进制字节流；
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（使用c++的instatceKlass方法，在元空间中创建该class的元数据，其中包括了一些信息，如父类、methods、常量池、成员方法等。同时暴露处一个java_mirror,即java类的镜像。）；
* 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。其中指向元空间的java_mirror，之后通过反射获取的信息都从元空间获取
* 之后创建的实例对象的对象头指向上面的class对象

**连接阶段：** 

* 验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求      
* 准备：为类的静态变量分配内存，并将其赋默认值     （1.8之后静态变量跟着class对象分配在堆内存中）   如果static变量是final的基本类型，赋值在准备阶段，如果static变量是final的引用类型，赋值在初始化完成  
* 解析：将常量池中的符号引用替换为直接引用（内存地址）的过程  因为使用的懒加载，在类被读入之后，只是记为一个符号引用，放在常量池中，当确实需要该对象时，才会进行展开，变为直接引用，加载为有具体信息的类

**初始化阶段：** 为类的静态变量赋初值

java虚拟机严格规定了有且只有如下5种情况必须立即进行初始化（初始化前，必须经过加载、验证、准备阶段）：

（1）使用new实例化对象时，读取和设置类的静态变量、静态非字面值常量（静态字面值常量除外）时，调用静态方法时。

（2）对内进行反射调用时。

（3）当初始化一个类时，如果父类没有进行初始化，需要先初始化父类。

（4）启动程序所使用的main方法所在类

（5）当使用1.7的动态语音支持时。

以上被称为主动引用，主动引用一定会进行初始化；其他情况称为被动引用，被动引用不会导致初始化，但是可能会进行验证、准备、解析





## 2.3 一条线程的创建过程

* main方法运行时进入栈中,创建新线程在栈中开辟新空间使用,栈空间相互隔离
* new的对象和对象中的成员变量进入堆,生成的地址值返回给栈去获取
* 每一个线程的栈中去执行自己的线程任务(run方法中的方法体)



## 2.4 对象的创建过程

类加载检查、分配内存、初始化零值、设置对象头、执行init方法



# 3. 垃圾回收

## 3.1 垃圾回收过程

垃圾回收主要发生在堆内存中。主要分为新生代和老年代。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303103706156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyMDM1NQ==,size_16,color_FFFFFF,t_70)

​	新生区 又分为 伊甸园区Eden，survivor（from，to）。 其中使用轻量级GC。在一开始新创建的对象存放在Eden，当Eden满之后，会进行一次minor GC，然后将存活对象复制到to，年龄加一，交换from和to，然后继续在Eden中进行创建。当再满时，minorGC，然后Eden和from区中的存活对象一起复制到to区，然后交换from和to，继续进行。达到条件之后仍然存活的对象进入老年代。老年代满之后，进行fullGC，进行标记清除，之后老年代再满之后，继续标记清除，达到一定数量之后，进行压缩，整理碎片空间。

​	minorGC会引发stop the word，暂停其他用户线程，等垃圾回收结束之后再恢复。minorGCSTW时间较短

​	在fullGC之前会先尝试进行minorGC，因为fullGC的STW时间较长

​	老年区 重量级GC（full GC） 但99%的变量不会永久使用 所以老年去比较少
​	永久区 JDK8以后改名为 元空间 这个区域常驻内存，用来存放JDK自身携带的class对象。interface元数据，存储的是java运行时的一些环境 这个区域不存在垃圾回收 只有在JVM关闭时会释放该部分内存

* 新生代进入老年代的条件
  * Eden区满时，进行Minor GC，当Eden和一个Survivor区中依然存活的对象无法放入到Survivor中，则通过分配担保机制提前转移到老年代中。 
  * 若对象体积太大, 新生代无法容纳这个对象，-XX:PretenureSizeThreshold即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对Serial及ParNew两款收集器有效。
  * 长期存活的对象将进入老年代。 默认经过16次轻GC仍然存活的对象进入老年代
  * 动态对象年龄判定。虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。

## 3.2 垃圾回收算法

​		垃圾回收并不会将内存进行清零，而是将需要回收的地址放入空闲地址表，等需要进行内存分配时直接使用就可以

- 引用计数法（用的比较少了 需要每个对象都分配计数器，会占用内存）

- 标记清除法：进行两次遍历，第一次遍历对活着的对象进行标记，第二次遍历对没有标记的对象进行清除

  不占用额外空间，但是会产生内存碎片 ，速度块

- 标记压缩法：清除之后堆内存空间进行压缩，没有内存碎片，但增加遍历，增加时间成本。

- 复制算法：先对对象进行标记，然后将from区存活对象全部复制到to区 ，在复制过程中完成了内存的整理，之后再将原来的from区和to区互换。没有内存碎片，但浪费内存空间。新生代存活率低，比较适用。

- GC（分代清除算法） 新生代使用复制算法、老年代使用标记清除压缩

## 3.3 垃圾回收器

### 如何判断对象已死？

* 引用计数法：给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。
* 可达性分析：通过一系列的称为 "GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。
  * GCroot的选择
  * a. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  * b. 方法区中类静态属性引用的对象。
  * c. 方法区中常量引用的对象。
  * d. 本地方法栈中 JNI（Native方法）引用的对象

## 常用的垃圾回收器

### **CMS收集器**

​	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：

* 初始标记（CMS initial mark）
* 并发标记（CMS concurrent mark）
* 重新标记（CMS remark）
* 并发清除（CMS concurrent sweep）



 	其中，初始标记、重新标记这两个步骤仍然需要"Stop The World"。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

缺点：

* **导致吞吐量降低。** 在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。
* **CMS 收集器无法处理浮动垃圾**  无法清除并发清除阶段产生的垃圾，需要预留一段空间来处理在清除的同时产生的垃圾
* **产生空间碎片** CMS 是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生

### G1垃圾收集器

G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用复制算法，碎片化问题不严重。***\*整体上看属于标记整理算法,局部(region之间)属于复制算法。\****

特点：

* **并行与并发** 使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，

* **分代收集** 能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果

* **空间整合：** G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。

* **可预测的停顿**：  **G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集**

  **G1 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是Garbage-First名称的来由），保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。**

G1回收主要分为三个过程：新生代GC、混合回收（新生代和老年代）、FullGC（）

其中回收运作又大致可划分为以下几个步骤：

- 初始标记（Initial Marking）  找GCroot关联的对象进行标记，伴随一次新生代GC，STW，全局停顿
- **根区域扫描**：**将扫描由survivor区直接可达的老年代区域，并标记这些直接可达的对象。** 
- 并发标记（Concurrent Marking）  并发标记将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发过程，并且这个过程可以被一次新生代GC打断。
- 最终标记（Final Marking）重新标记也是会使**应用程序停顿**，由于在并发标记过程中，应用程序依然运行，因此标记结果可能需要修正，所以在此阶段对上一次标记进行补充。并且使用SATB（Snapshot-At-The-Begining）算法，会在标记之初为存活对象创建一个快照，加快重新标记的速度
- **独占清理**：顾名思义，这个阶段会引起**停顿**。它将计算各个区域的存活对象和GC回收比例并进行排序，识别可供混合回收的区域。在这个阶段，还会更新记忆集。该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段，需要这些信息。
- 筛选回收（Live Data Counting and Evacuation）



# 4. JMM模型

​		JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。

Java内存模型是围绕着并发编程中**原子性、可见性、有序性**这三个特征来建立的。

## happens-before

如果两个操作满足happens-before原则，那么不需要进行同步操作，JVM能够保证操作具有顺序性，此时不能够随意的重排序。否则，无法保证顺序性，就能进行指令的重排序。





