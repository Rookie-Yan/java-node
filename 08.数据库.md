# 1. 事务的基本要素、隔离级别

## 1. 事务的基本要素及实现

* **原子性（Atomicity）**：事务开始后所有操作，要么全部完成，要么全部不完成。  undo log
* **一致性（Consistency）**：事务开始前和结束后，数据库的完整性约束没有被破坏 。
* **隔离性（Isolation）**：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。MVVC+undolog
* **持久性（Durability）**：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚。 redolog

InnoDB 存储引擎还提供了两种事务日志：`redo log`（重做日志）和`undo log`（回滚日志）。其中，`redo log`用于保证事务持久性；`undo log`则是事务原子性和隔离性实现的基础。**一致性的实现既需要数据库层面的保障，也需要应用层面的保障**。

`undo log`：当事务对数据库进行修改时，InnoDB 会生成对应的`undo log`；如果事务执行失败或调用了`rollback`，导致事务需要回滚，便可以利用`undo log`中的信息将数据回滚到修改之前的样子。`undo log`属于逻辑日志，它记录的是 SQL 执行的相关信息。当发生回滚时，InnoDB 会根据`undo log`的内容做与之前相反的工作。insert--delete   delete--insert  update--update

**WAL(write-ahead logging )**  InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中，这一过程称为“刷脏”。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果 MySQL 宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是 WAL（**Write-ahead logging，预写式日志**），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。

## 2.隔离级别、存在问题、如何实现

**隔离级别：**

事务的隔离级别分为：***\*读未提交(read uncommitted)、读已提交(read committed)、可重复读(repeatable read)、串行化(serializable)。\****

* 读未提交：A事务已执行，但未提交；B事务查询到A事务的更新后数据；A事务回滚；---出现脏数据

* 读已提交：A事务执行更新；B事务查询；A事务又执行更新；B事务再次查询时，前后两次数据不一致；---不可重复读

* 可重复读：A事务无论执行多少次，只要不提交，B事务查询值都不变；B事务仅查询B事务开始时那一瞬间的数据快照；  **MYSQL默认隔离级别**

* 串行化：不允许读写并发操作，写执行时，读必须等待；

  

**存在问题：**

* 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

* 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

* 幻读：A事务读取了B事务已经提交的新增数据。

  ​		注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。**不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。**

![image-20210523172107563](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210523172107563.png)



在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了**读数据情况下的幻读问题**。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。 **通过索引加锁，间隙锁，next key lock可以解决幻读的问题。**



**如何实现：**

1. 使用锁机制：

   脏读：**修改**时加**排他锁**，直到事务**提交后才释放**；**读取**时加**共享锁**，不允许任何事物操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，    			仍然存在不可重复读的问题：当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题

   不可重复读、幻读：**读**取数据时加**共享锁**，**写**数据时加**排他锁**，都是**事务提交**才**释放**锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题

2. MVCC多版本并发控制

   InnoDB的MVCC，**通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间）**。**每开始一个新的事务，系统版本号就会递增**。实现并发控制，又有快照读和当前读。

   快照读，读取的是记录数据的可见版本（可能是过期的数据），在事务一开始就创建，之后的操作不再影响它，不用加锁；

   当前读，读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录，读在快照之后都已经提交的事务

   在RR（可重复读）隔离级别下，select使用快照读，其他使用的是当前读。（所以不能从根本上解决幻读的问题）

   在RC（读已提交）隔离级别下，使用的全是快照读。
   
   其实在进行操作的时候，每一条数据都会有ReadView，记录的是其版本以及对应的数据，快照读就是只招该事务创建的时间点，之前的已提交的最新数据，而当前读就是以当前时间为节点，所以事务的已提交的数据



# 2.  索引

索引（Index）是帮助数据库高效获取数据的数据结构。使用索引可以提高查询效率。

## 1. 索引为什么使用B+树？

B+树使用树+链表的结构，非叶子节点存储用来存储索引，叶子节点存储数据，其中叶子节点构成链表，指向相邻的叶子节点。既保存了B树查询效率高的特点，也克服了B树读写慢、遍历慢的缺点。

为什么不使用其他数据结构作为索引？

​		Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。

​		二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。

​		平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。

​		红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。

​		B树：B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。因为B树的数据存放在叶子节点，导致每次磁盘读取的数据有限，从而增加了IO次数，降低了查询的效率。而且元素遍历也是大问题。

## 2.索引的分类

**主键索引:** 数据列不允许重复，不允许为NULL，一个表只能有一个主键。

**唯一索引:** 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。

**普通索引:** 基本的索引类型，没有唯一性的限制，允许为NULL值。

**全文索引：**是目前搜索引擎使用的一种关键技术。

​		建立使用ALTER TABLE 'table_name' ADD FULLTEXT('col')，使用时where match(col1，col2) against('xxx xxx');

​		数据量总数大于等于4，匹配字段长度大于等于4才能使用全文索引。

**组合索引：**多个属性组合构成索引。

​		联合索引在建立时其实相当于建立了多个索引，从左至右，每次多一个元素。如abc，其实建立了a，ab，abc三个索引

​		最左匹配原则：联合索引建立时是以最左边元素为基准进行排序的，然后是后边的元素。在进行查找时，也是按照相应的顺序查找，如果缺失左边元素的查找条件，右边元素就不会走索引（如果索引顺序为abc，但查询条件是a>1 and c>1，这样只会走a的索引，因为b的条件不限制）。只要不是最左边元素，遇到<，>，between等都会使索引失效，因为建立的时候仅有最左边元素是按照正确顺序排的。

## 3. 索引的使用

1. 索引的设计原则

   * 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
   * 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
   * 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
   * 尽量避免NULL：应该制定列为NOT NULL，在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。
   * 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。
   * 简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂

2. 创建索引的原则

   * 最左前缀匹配原则：mysql联合索引遇到范围查询(>、<、between、like)就停止匹配，所以要把常用做范围查询放在最后
   * 较频繁作为查询条件的字段才去创建索引
   * 更新频繁字段不适合创建索引
   * 若是不能有效区分数据的列不适合做索引列
   * 尽量的扩展索引，不要新建索引。
   * 定义有外键的数据列一定要建立索引。
   * 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。（例如性别，重复值很多）
   * 对于定义为text、image和bit的数据类型的列不要建立索引。

3. **什么情况下不走索引？**

   * order by 和 limit 结合使用，遇到此类状况可以考虑用子查询将order by 和 limit 分开。
   * DATE_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。
   * 子查询中order by的索引会失效，同时可能导致子查询中的where条件索引都不能用。
   * 字符集的使用导致不走索引，有时你会发现用一个SQL 条件值不同可能会有天的差别
   * **like模糊查询%在左边，如果需要，应该使用覆盖索引，当like的属性包含在某个索引里，而且查询时只查询索引中有的属性，即使%key% 也会走索引** 
   * 列类型为字符串类型，查询时没有用单引号引起来 
   * 在where查询语句中使用表达式 
   * 在where查询语句中对字段进行NULL值判断 
   * 在where查询中使用了or关键字, myisam表能用到索引， innodb不行;(用UNION替换OR,可以使用索引)
   * 全表扫描快于索引扫描（数据量小时）

4. 索引的创建

   **CREATE INDEX index_name（索引名） ON table_name（表名称） (column_list（以哪一列元素作为索引）);**

5. 执行计划

   explain + sql语句   可以获得的信息

   - 表的读取顺序
   -  数据读取操作的操作类型
   -  哪些索引可以使用
   -  哪些索引被实际使用
   -  表之间的引用
   -  每张表有多少行被优化器查询

## 4. 聚簇索引和非聚簇索引

**聚簇索引：非叶子节点存储索引，叶子节点存储数据。索引和数据存储在一起。**

**非聚簇索引：索引和数据分开，叶子节点和非叶子节点都存储索引，只不过另外指向数据位置。**

​		对于Innodb来说，每一张表都会有一个聚簇索引，除此之外都为非聚簇索引，也为辅助索引。如果表中有主键，就会**将主键索引设置为聚簇索引**，如果不定义主键，就会选择**第一个并且没有null值的唯一索引作为主键**，成为聚簇索引，如果没有这样的列，innoDB就**自己产生一个六字节的隐藏ID，作为聚簇索引**



# 3. SQL语句的执行

## 1. SQL的执行顺序

**from > join on > where > group by > having > select > distinct > order by > limit**

having是在分组后对数据进行过滤
where是在分组前对数据进行过滤
having后面可以使用聚合函数
where后面不可以使用聚合

## 2. 一条SQL的执行过程

![img](https://img-blog.csdnimg.cn/20210407205449259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyMDM1NQ==,size_16,color_FFFFFF,t_70)

1. 首先获取连接器，连接器负责跟客户端建立连接、获取权限、维持和管理连接。
2. 然后查询缓存，之前查询的sql和结果会以键值对的形式进行存储，如果查询过，就将value直接返回，但是mysql8之后删除了
3. 如果没有缓存，就需要走分析器，分别进行词法分析和语法分析
4. 之后使用优化器对语句进行优化，确定使用什么索引，如何进行连表等
5. 执行器执行
6. 存储引擎，进行读写操作

## 3. join on  的使用

- 左表 inner join 右表 on 条件 ：两张表都有的 满足条件的才会被查询出来
- 左表 left join 右表 on 条件 ：先把左表全部查询出来，然后满足条件的右表的数据被加上去
- 左表right join 右表 on 条件 ：先把右表查询出来，然后满足条件的左表数据被加上去

## 4. 如何优化SQL语句

* 在表中建立索引，优先考虑where、group by使用到的字段。
* 尽量避免使用select *，返回无用的字段会降低查询效率
* 尽量避免使用in 和not in，会导致数据库引擎放弃索引进行全表扫描。
* 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。
* 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描
* 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。
* 尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。
* 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描  
* 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引
* 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 



## 5. 数据库设计的三大范式

**第一范式条件**：必须不包含重复组的关系，即每一列都是不可拆分的原子项。第一范式就是无重复的列。

**第二范式条件**：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。  第二范式就是非主属性依赖于主关键字。

**第三范式的条件：**关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。第三范式就是属性不依赖于其它非主属性。



## 6. MYSQL的缓存机制

​		一级缓存默认开启，作用域是sqlsession，在一起session会话中，可以使用缓存查询。在连接器建立之后，先不走查询语句，先看缓存中时候有需要的sql以及对应的结果集，如果有就直接时候，没有再查询，之后将查询结果放入缓存中。

​		二级缓存是由Mybatis提供的，跨session使用，所有的session都可以使用。

​		对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。

* 传入的statementId

* 查询时要求的结果集中的结果范围

* 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串(boundSql.getSql() )

* 传递给java.sql.Statement要设置的参数值



# 4. 锁机制

## 1. 行锁、表锁、间隙锁

行级锁：是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。 

表级锁：是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁

间隙锁：对满足查询条件的数据范围进行加锁，如id>100   即使只有一个数据，其他数据间隙也会被加锁，不允许写操作，可以防止幻读

## 2. 共享锁、排他锁

**共享锁（s）：又称读锁。**允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 允许别人读，但不能写    select ... lock in share mode

**排他锁（Ｘ）：又称写锁。**允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。  不允许别人读和写  for update









# 5. 常见问题

## 1. count* 与count（1）、count（列名）

count * 与count 1 区别不大，在数据列很多的时候，count 1 效率更高，两者都不过滤null值

count（列名）会过滤值为null的数据

执行效果上：  
count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL  
count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL  
count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。

执行效率上：  
列名为主键，count(列名)会比count(1)快  
列名不为主键，count(1)会比count(列名)快  
如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（* ）  
如果有主键，则 select count（主键）的执行效率是最优的  
如果表只有一个字段，则 select count（*）最优。

## 2. 查询%aaa%使用索引

* **使用索引覆盖。**将需要使用%aaa%模糊查询的字段建立联合索引，然后在查询时，查询的数据也需要包含在联合索引中，至此完成索引的覆盖，只需要查询索引中有的字段即可，不会走全表。如联合索引为 name，age，address，如果select name form table where address like “%aaa%” 就可以使用索引，但是如果使用sleect * from table where address like “%aaa%”就只能走全表扫描
* **使用全文索引。** 使用ALTER TABLE 'table' ADD FULLTEXT('address')建立索引后，查询时使用select * from table where  match(address) against('aaa');但是全文检索具有一定条件，**总数据量大于4**才会走全文索引，**匹配字段长度大于等于4**才会走全文索引（“aaa”其实不走，但是“aaaa”会走）



