



# 1. 总体架构模型



<img src="https://img-blog.csdnimg.cn/20210316215618605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyMDM1NQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />



<img src="https://img-blog.csdnimg.cn/20210316220442750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzgyMDM1NQ==,size_16,color_FFFFFF,t_70" alt="img"  />

<img src="D:\Typora\image\image-20210726102353064.png" alt="image-20210726102353064" style="zoom:80%;" />



# 2. 传输层常用协议

## 1. TCP协议



**TCP是面向连接的、可靠的、基于字节流的传输层通信协议。**

* 面向连接：一对一，需要建立连接
* 可靠的：不会丢包
* 基于字节流：消息是没有边界的，无论多大都可以传输



### TCP数据包格式

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520095409917.png" alt="image-20210520095409917" style="zoom:80%;" />

**序列号**：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。**⽤来解决⽹络包乱序问题。**

**确认应答号**：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**⽤来解决不丢包的问题。**

**控制位：**

*ACK*：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。

*RST*：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。

*SYN*：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。

*FIN*：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段



#### 建立TCP连接的条件

客户端与服务器对三个参数进行统一

* Socket：由 IP 地址和端⼝号组成

* 序列号：⽤来解决乱序问题等

* 窗⼝⼤⼩：⽤来做流量控制

#### 确定一个TCP连接

四元组：源地址、源端口、目标地址、目标端口

源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。

源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。

![image-20210520100107151](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520100107151.png)







## 2. UDP数据报格式



<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520100253442.png" alt="image-20210520100253442" style="zoom:80%;" />





* 目标和源端口：主要是告诉 UDP 协议应该把报⽂发给哪个进程。
* 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。
* 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。



## 3. TCP和UDP的区别

1. 连接

   * TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。

   * UDP 是不需要连接，即刻传输数据。

2. 服务对象

   * TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点
   * UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信

3.  可靠性

   * TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。
   * UDP 是尽最⼤努⼒交付，不保证可靠交付数据。

4.  拥塞控制、流量控制

   * TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
   * UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。

5.  传输⽅式

   * TCP 是流式传输，没有边界，但保证顺序和可靠。
   * UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。

6.  ⾸部开销

   * TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。
   * UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩

7.  分⽚不同

   * TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传

     输丢失的这个分⽚。

   * UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，

     在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。



使用场景

* TCP：文件传输、HTTP/HTTPS
* UCP：视频、音频通信、广播通信、包总量较少的通信



## 4. TCP三次握手

![image-20210520101337659](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520101337659.png)



1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SENT状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。



#### 为什么是三次，不是两次、四次？

* 保证双方都具有接收和发送的能力
* 两次握手可能会存在历史连接问题，从而造成死锁。三次握手可以避免。两次握手无法防止历史连接的建立，会造成双方资源的浪费，无法可靠的同步序列号
* 正常四次是可以的，但是服务器应答和服务器发送数据可以合并未一次，所以是三次

## 5. TCP四次挥手

![image-20210520105807608](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520105807608.png)



1. 第一次分手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

#### 为什么是四次挥手？

​	TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

#### 为什么需要TIME_WAIT？

* 防⽌具有相同「四元组」的「旧」数据包被收到；

  因为网络阻塞等原因，可能会有先发送的数据晚于FIN被客户端接收，所以需要进行一定时间的等待

* 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭

  如果对方没有接收到ACK，就会继续发送FIN，TIME_WAIT可以保证能够接收到因为没有关闭发送的FIN，帮助正常关闭

#### TIME_WAIT为什么是2MSL？

MSL 是 Maximum Segment Lifetime，**报⽂最⼤⽣存时间**，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。

⽹络中可能存在来⾃发送⽅的数据包（包括一开始发送但延时送达的），当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以**⼀来⼀回需要等待** **2** **倍**

**的时间**。

2MSL 的时间是从**客户端接收到** **FIN** **后发送** **ACK** **开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK没有传输到服务端，客户端⼜接收到了服务端᯿发的 FIN 报⽂，那么 **2MSL** **时间将重新计时**。

#### 建立了连接但客户端故障了怎么办？

​		TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



## 6. TCP拥塞控制

在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫做**网络拥塞**。

在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。

若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731190238241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

**四种拥塞控制算法：**慢开始、拥塞避免、快重传、快恢复

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731155254165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731165743903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

**慢开始：** 拥塞窗口cwnd大小从1开始进行平方增长，直到达到初始的慢开始门限ssthresh，然后使用拥塞避免算法

**拥塞避免：** 拥塞窗口由当前值每次增长1，直到发生超时重传，此时将慢开始门限ssthresh更新为原来的一般，拥塞窗口cwnd大小更新为1，重新进行慢开始

**存在问题：** 有可能是超时重传或数据丢失，需要重新发送单个数据，并不是网络拥塞，此时直接重新慢开始，会降低效率。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184314574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184640178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)



# 3. 应用层常用协议

## 1. DNS协议

域名解析协议，用来解析域名，获取对应连接，在区域传输使用的是TCP，其他时候使用UDP协议（域名解析使用UDP）

**DNS解析流程**

1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址    
2. 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果    
3. 请求本地域名服务器（LDNS）来解析这个域名    
4. 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析    
5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址    
6. 此时LDNS再发送请求给上一步返回的gTLD    
7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器    
8. Name Server根据映射关系表找到目标ip，返回给LDNS    
9. LDNS缓存这个域名和对应的ip    
10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束    



## 2. AMQP协议

​		高级消息队列协议，是一个进程间传递**异步消息**的**网络协议**。基于TCP协议，是一个二进制协议。主要分为Producer（生产者）、Breoker（节点）、Consumer（消费者）。生产者消费者不直接进行关联，而是通过Breoker实现消息传递。主要应用就是消息中间件，RabbitMQ

**流转过程：**

生产过程：建立连接（生产者与节点）、开启通道、发送消息、释放资源

消费过程：建立连接（消费者与节点）、开启通道、（消费者）准备接收、（Breoker）发送消息、发送确认、释放资源

**为什么要使用通道？**

因为协议是基于TCP开发的，需要三握四挥，而通道是长连接，当传输结束在断开即可，可以减少多次连接耗费时间和资源



## 3. FTP协议

​		文本传输协议。FTP使用交互式的访问，允许客户指定文件的类型和格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。文件传输协议有基于TCP的FTP和基于UDP的简单文件传输协议TFTP，它们都是文件共享协议中的一大类，若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件传回到原节点。**基于TCP协议**

## 4. SMTP协议

​		简单邮件传输协议。SMTP 是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。它是一组用于由源地址到目的地址传送邮件的规则，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。

​		第一步用 MAIL 命令给出发送者的身份，第二步用一个或者多个RCPT命令给出接收者信息，接着用DATA命令给出邮件数据。

```java
S: MAIL FROM:<Smith@Alpha.ARPA>
R: 250 OK
S: RCPT TO:<Jones@Beta.ARPA>
R: 250 OK
S: DATA
R: 354 Start mail input; end with <CRLF>.<CRLF>
```



## 5. HTTP/HTTPS协议

​		**超文本传输协议**

### 1. 常见状态码

![image-20210520112948732](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520112948732.png)



「**200 OK**」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body数据。

「**204 No Content**」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「**206 Partial Content**」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。

「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。

「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

「**403 Forbidden**」表示服务器禁⽌访问资源，并不是客户端的请求出错

「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

「**501 Not Implemented**」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思

「**502 Bad Gateway**」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。

「**503 Service Unavailable**」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。

### 2. 报文组成

请求：

* 请求行：请求方法字段、URL字段和HTTP协议版本

* 请求头：key value形式，还有很多，只列举部分

  ![image-20210622214406842](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210622214406842.png)

* 请求体：具体数据

* 空行：发送回车符和换行符，通知服务器以下不再有请求头

响应：

* 状态行
* 消息报头
* 响应正文

### 3. 转发和重定向的区别

![image-20210520114443816](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210520114443816.png)

1、转发使用的是getRequestDispatcher()方法;重定向使用的是sendRedirect();

2、转发：浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变；

3、转发是服务器行为，重定向是客户端行为；

4、转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求；

5、转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。

6、转发的范围限制在服务器内部，重定向没有限制

### 4. GET和POST的区别

* GET从服务器获取资源，POST向服务器发送数据
* GET传输的数据量小，受到URL长度限制，但是效率高；POST传输数据量没有限制，文件传输需要POST
* GET不安全，URL明文传输；POST安全性高，信息封装在请求实体中
* GET只支持ACSII，可能会乱码；POST支持标准字符集，能正确传递中文字符
* GET是安全幂等的，POST是不安全不幂等的：安全：不会修改服务器信息  幂等：多次操作结果是一样的

### 5. HTTP的缺点

* 通信使⽤明⽂（不加密），内容可能会被窃听。
* 不验证通信⽅的身份，因此有可能遭遇伪装。
* ⽆法证明报⽂的完整性，所以有可能已遭篡改。
* HTTP**S** 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：
  * **信息加密**：混合加密，交互信息⽆法被窃取
  * **身份证书**：将服务器公钥放⼊到**数字证书**中，解决了冒充的⻛险
  * **校验机制**：**摘要算法**的⽅式来实现**完整性**，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。⽆法篡改通信内容，篡改了就不能正常显示

### 6. HTTP与HTTPS的区别

1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。

2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。

3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。

4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。





### 7. HTTPS传输

#### HTTPS传输过程

1. 客户器发起HTTPS请求到服务器
2. 服务器端返回证书给客户端，其中包含公钥
3. 客户端对证书进行验证，是否合法、是否过期
4. 验证成功后本地生成随机数，然后通过公钥加密之后发送到服务器端
5. 服务器端通过私钥对随机数进行解密
6. 之后数据交互通过对称加密进行传输

#### HTTPS加密（混合加密）

* 在建立连接阶段，使用非对称加密，交换后续数据传输的密钥 **常用RSA算法**
* 在传输数据阶段，使用对称加密，对数据进行传输 **常用ASE算法**

#### 为什么要采用混合加密？

* **对称加密**只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。
* **⾮对称加密**使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。

#### 为什么数据传输使用对称加密？

* 一对公私钥只能实现单向传输，因为私钥在一个人手中，只能它进行解密
* 非对称加密数据传输效率慢





### 8. Session和cookie

#### **1.Cookie的工作原理**

（1）浏览器端第一次发送请求到服务器端
（2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端
（3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie
（4）服务器端通过Cookie中携带的数据区分不同的用户（cookie信息存放在HTTP请求头里的Cookie中）
										![在这里插入图片描述](https://img-blog.csdnimg.cn/20190917204655188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70)

#### **2.Session的工作原理**

（1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的			ID），然后将该Cookie发送至浏览器端
（2）浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
（3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。
		name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie
		name为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象
		value为SessionId不存在**（Session对象默认存活30分钟）**，返回1中重新去创建Session与特殊的Cookie
		value为SessionId存在，返回session对象

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091720521815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091720523621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70)

#### **3. 区别和对比**

* cookie数据存放在客户的浏览器上，session数据放在服务器上
* cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session，所以cookie中可以存放无关用户安全的信息，但是与安全相关的信息应该放在session中
* session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
* 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。
* session默认有保持连接的时间，可以设置，cookie在关掉客户端之后就会断开，但是可以设置保存在本地



### 9. Token和JWT

#### 1. 传统session和cookie的缺点

* session会占用服务器资源，如果用户过多，全部存储在服务器上，会曹正较大的资源占用
* session无法解决分布式问题，即如果在一台服务器存储了session，无法访问其他分布式资源
* cookie不够安全，容易被攻击
* cookie是可以被用户禁止的，如果禁止，造成业务功能失效

#### 2. Token的优点和缺点

* 无状态，可扩展：负载均衡器能够将用户信息从一个服务传到其他服务器上。
* 安全性：使用令牌，站点不存储信息，而且具有失效性（存储在redis中可以设置过期时间）
* 支持多平台跨服务器（redis本身就是中间件，可以跨平台）
* 可扩展性：Tokens能够创建与其它程序共享权限的程序

#### 3. Token如何使用

1. 用户通过用户名和密码发送请求。

2. 服务端验证,  返回生成的token 令牌给客户端,  同时给数据库和Redis里关联token和用户信息。

3. 客户端储存token,并且其后的每一次请求都添加token, token应该在HTTP的头部发送从而保证了Http请求无状态。

4. 服务端查询Redis+数据库, 验证token并返回数据。

#### 4. JWT 如何使用

* 组成：Header（编码信息等）+payload（自定义信息）+签名（防止信息篡改）  前两项直接使用base64url进行**编码**，最后一部分使用HS256(一种加密算法)将前两部分信息进行加密，为了防止被对比解码，可以进行加盐值
* 使用：
  * 用户第一次登录成功后，使用 jwt 创建一个 token，并给用户返回，保存在客户端的 localStorage 中
  * 以后用户再次访问时，需要携带 token，服务端获取token后，再做 token 的校验（服务端不存储token）
  * 服务端获取token后，对token进行切割，切割为三部分
  * 对第二段密文进行 base64url 解密为明文，并获取 payload 信息，检测 token 是否已经超时？
  * 把第1、2段密文拼接，再次执行 HS256 加密，将加密后的密文 与 使用 base64url 解密后的第3段密文进行比较，如相等，则 token 未被修改过（认证通过）

#### 5. JWT与Token的对比

* Token需要每次验证进行校验，需要访问数据库，并没有减轻数据库的压力
* JWT无法像token一样，一旦生成，很难修改和销毁，所以一般设置的过期时间较短
* JWT可以直接将信息编译为字符串，所以在验证时只需要进行反编译，不需要访问数据库（所以不能存放敏感信息）



## 6. Http的升级

* **HTTP1.0:** 
  * **无状态**，服务器不跟踪每个客户端，也不记录过去的请求，使用session和cookie实现状态存储
  * **无连接**（短连接），服务器相应之后会立刻断开，资源消耗大，无法无用连接
  * **无host头**，因为默认一个IP对应一台电脑
  * **队头阻塞**，请求是一个一个来的，需要处理完前面请求之后才能处理后续
* **HTTP1.1:**
  * **使用connection:keep-alive使用长连接**
  * **请求管道化**  虚假的并行  提升一定的传输速度
  * **增加缓存处理**（新的字段如cache-control）,增加了更多的缓存处理策略
  * **增加Host字段，支持断点传输等**
  * **新增了24个错误状态响应码**，丰富的错误码更加明确各个状态
  * 队头依旧是阻塞的
* **HTTP2：**
  * **二进制分帧**，将所有信息分隔成更小的消息和帧，采用二进制编码，提高吞吐量，改善传输性能
  * **多路复用：** 使用stream流，实现多路复用，一个TCP连接可以同时处理多个http请求
  * **头部压缩：**双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小
  * **服务器推送：**服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。
* **HTTP3:QUIC**
  * **无队头阻塞**：2.0多个请求在一个TCP连接中，如果一个数据包丢失，那么都需要进行重发，造成队头阻塞，QUIC基于UDP协议，多个stream相互独立，丢包直接重发即可
  * **建立速度快：**2.0有TCP和TLS握手时延，QUIC内部包含TLS1.3，连接建立更快
  * **连接迁移：**2.0由TCP四元组建立连接，当网络发生变化时，需要断开然后重新建立，切换网络成本较高，QUIC没有使用四元组绑定连接，使用特定的连接ID标记客户端和服务端，保存连接上下文，即使IP地址变化，也可以无缝转换，没有切换网络的成本

## 7. URL渲染过程

1. 查看缓存：先查看浏览器是否有页面缓存，是否有url对应的ip地址，是否需要发送请求
2. DNS解析，找到对应的IP地址
3. 三次握手，建立连接
4. 发送请求
5. 服务器返回请求数据
6. 客户端进行页面渲染
7. 四次挥手，断开连接



# 4. 网络层常用协议

<img src="D:\Typora\image\image-20210726103426490.png" alt="image-20210726103426490" style="zoom:50%;" />

​		在网际层，ICMP和IGMP是在IP协议之上的，依靠IP协议，ARP地址解析协议在最下层，IP协议要经常使用ARP协议进行地址解析

## 1. ICMP 网际控制报文协议

​		ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。**主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。**当遇到IP数据无法访问目标、IP[路由器](https://baike.baidu.com/item/路由器)无法按当前的传输速率转发[数据包](https://baike.baidu.com/item/数据包)等情况时，会自动发送ICMP消息。

​		ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。当路由器在处理一个数据包的过程中发生了意外，可以通过ICMP向数据包的源端报告有关事件。

​		其功能主要有：侦测远端主机是否存在，建立及维护路由资料，重导资料传送路径（[ICMP重定向](https://baike.baidu.com/item/ICMP重定向)），资料[流量控制](https://baike.baidu.com/item/流量控制)。ICMP在沟通之中，主要是透过不同的[类别](https://baike.baidu.com/item/类别)(Type)与[代码](https://baike.baidu.com/item/代码)(Code) 让机器来识别不同的连线状况。

​		ping 和 tracert是两个常用网络管理命令，**ping 用来测试网络可达性**，**tracert 用来显示到达目的主机的路径**。

​		ICMP报文包含在IP数据报中，属于IP的一个用户，IP头部就在ICMP报文的前面，所以**一个ICMP报文包括IP头部、ICMP头部和ICMP报文**，IP头部的Protocol值为1就说明这是一个ICMP报文，ICMP头部中的类型（Type）域用于说明ICMP报文的作用及格式，此外还有一个代码（Code）域用于详细说明某种ICMP报文的类型，所有数据都在ICMP头部后面。
​		原文链接：https://blog.csdn.net/fuhanghang/article/details/105506830



## 2. IGMP 网际组管理协议

​		IGMP用来**在接收者主机和与其直接相邻的组播路由器之间建立和维护组播组成员关系**。IGMP通过在接收者主机和组播路由器之间交互IGMP报文实现组成员管理功能，IGMP报文封装在IP报文中。

​		IP组播通信的特点是报文从一个源发出，被转发到一组特定的接收者。但在组播通信模型中，**发送者不关注接收者的位置信息，只是将数据发送到约定的目的组播地址**。要使组播报文最终能够到达接收者，需要某种机制使连接接收者网段的组播路由器能够了解到该网段存在哪些组播接收者，同时保证接收者可以加入相应的组播组中。IGMP就是用来在接收者主机和与其所在网段直接相邻的组播路由器之间建立、维护组播组成员关系的协议。

​	原文链接：https://blog.csdn.net/qq_38265137/article/details/80475475



## 3. IP 网际协议

### **IP协议**

​		**IP提供不可靠的，无连接的数据传送服务。**通过使用32位二进制数字进行寻址，为了方便记忆，将32位二进制记为4个3位10进制数字，其中使用 点 .  分割。

（1）不可靠指它不能保证IP数据报能成功到达目的地。
		IP仅提供最好的传输服务。当发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送**ICMP**消息给信源。任何要求的可靠性必须由上层来提供。
（2）无连接指IP并不维护任何关于后续数据报的状态信息。
		每个数据报的处理是相互独立的。IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B）每个数据报都是独立的进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。 
原文链接：https://blog.csdn.net/baidu_37964071/article/details/80467838

<img src="https://img-blog.csdn.net/20180527100255831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 50%;" />

​		IP地址分为5类，每一类都由网络号和主机号组成。其中A类一般为大型团体使用，主机号较多，但网络号少，而C类则为小型团体使用，主机号较少。

<img src="D:\Typora\image\image-20210726152453725.png" alt="image-20210726152453725" style="zoom:50%;" />

### **子网掩码**

​		为了能够让IP地址能够满足需求（数量不够），使用子网掩码使同一网络下有多个子网。子网掩码由32位二进制组成，与上IP地址可以获得主机的网络号。使用子网划分之后，原来的  **网络号+主机号** 变为 **网络号+子网号+主机号**

​		使用**子网掩码需要用掉原IP地址的主机号位置**，每类IP地址都由默认的子网掩码，对于某一个具体的**子网掩码，其与该所属类的子网掩码的1的位数的差就是使用子网划分所用到的主机号位数n**（如一个B类IP地址X的子网掩码为**255.255.240.0**，而B类的默认子网掩码为255.255.0.0，转为二进制可以看到X的子网掩码1的长度比默认的长4，所以就使占用了4位的主机号作为子网划分）。而**子网划分数为2^n-2个**，**主机数为2^(可以使用的主机号位数)-2**，（如原本主机号为16位，但4位用作子网划分，剩下12位，-2是因为全0和全1不能使用，留有特定功能）。

​		当子网掩码与上IP地址后，子网划分处的数字即为子网号，子网掩码取反再与上IP地址可以得到主机号，广播地址则为主机号全部置为1的地址，主机地址范围为主机地址从1到除了末位全为1。

​		除此之外，使用CIDR表示子网掩码，/n，n即为子网掩码中1的位数长度。如192.168.1.100/25，其子网掩码为255.255.255.128

| 地址类型 | 特征                           | 网络范围 | 默认掩码      |
| :------- | :----------------------------- | :------- | :------------ |
| A类地址  | 第1个8位中的第一位始终为0      | 0-127    | 255.0.0.0     |
| B类地址  | 第1个8位中的第1、2位始终为10   | 128-191  | 255.255.0.0   |
| C类地址  | 第1个8位中的1、2、3位始终为110 | 192-223  | 255.255.255.0 |

​		使用子网掩码可以判断两个主机是否在同一子网，在同一子网的主机可以直接通信，不再同一子网的主机不能直接通信。

子网掩码：https://blog.csdn.net/bbj12345678/article/details/105972092
子网掩码计算：https://blog.csdn.net/wei763328075qq/article/details/103521545   但是主机号那块计算不正确

**划分子网作用：**减少了广播域、有效规划和利用IP、安全性高方便管理

**子网掩码的作用：** 可以获取子网号，判断是否处于同一子网



## 4. ARP 地址解析协议

​		其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而**将已知IP地址转换为MAC地址**的工作是由ARP协议来完成的。

​		在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。
​		原文链接：https://blog.csdn.net/ever_peng/article/details/80008638

## 5. RARP 反向地址解析协议

​		已淘汰，之前和ARP地址解析协议配合使用。





# 进行数据通信的整体流程

![img](https://img-blog.csdnimg.cn/20200118204511270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Byb2dyYW1tZXJfSno=,size_16,color_FFFFFF,t_70)

​		当需要进行数据传输时，发送数据的主机指定目的主机需要打开的端口，自身会打开一个大于1024的随机端口，然后应用层会先在数据前端添加引用层首部，然后交给传输层。

​		传输层会在上一步的整体前端添加TCP首部，然后进行三次握手建立连接。

​		然后将其传给网络层，网络层会添加IP地址的首部。然后通过ARP协议进行转换，首先查看ARP缓存是否有目标IP的MAC地址，如果有，就直接加上首部和尾部封装成MAC地址，交由数据链路层进行传递，如果没有缓存，就进行广播，获取到目标的MAC地址，然后缓存，再交给数据链路层传递。但是有可能目的主机不再同一网段，此时需要在中间经过网关进行传输，直接将MAC地址设为路由器的地址，路由器在收到之后，剥离原MAC帧头，查看自己的ARP缓存，如果没有，继续广播然后缓存，然后封装MAC地址，进行传输。

​		然后通过MAC地址进行传输，到达目的主机后对比MAC头部，如果一致，去掉MAC封装之后，交给网络层，网络层对比IP地址，无误之后交给传输层，传输层对比TCP首部，如果没有问题交给应用层，然后去掉应用层首部，接收到数据。

​		数据传输结束之后，四次挥手，结束连接。


原文链接：https://blog.csdn.net/Programmer_Jz/article/details/104033569

ARP转发：https://www.cnblogs.com/lolau/p/8137541.html

<img src="https://img-blog.csdn.net/20180323171937303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTk4MTUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:67%;" />

​	**内网与外网的通信：NAT地址转换技术**

* 网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关

* 网络访问只能先由私网侧发起，公网无法主动访问私网主机；

* NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换；

* NAT网关的存在对通信双方是保持透明的；

* NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。

  原文链接：https://blog.csdn.net/gui951753/article/details/79593307

​	

